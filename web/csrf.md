This document was heavily based on Portswigger Web Security Academy.

For the cheatsheet, go to <a href="scripts/csrf.html">scripts/csrf.html</a>.

# Basics of CSRF

Cross-Site Request Forgery (CSRF) is a vulnerability where an attacker is able to make a request to a target website on behalf of a victim. It can be performed when the application solely relies on session cookies for authentication, and the action does not contain parameters whose values the attacker needs to know or determine.

For example, to change the e-mail of a victim in an application, the attacker may construct a web page containing the following HTML code:
```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

If a victim visits the attacker's webpage, the page will trigger an HTTP request to the vulnerable website. If the victim is logged in to the vulnerable website, their browser will automatically include their session cookie in the request and it will be processed normally, as if it had legitimally been made by the victim.

We usually can combine XSS with CSRF. Some simple CSRF exploits employ a GET method and can be fully contained in a single URL. The attacker can directly feed the victims with a malicious URL like
```html
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```

Nowadays there are defense measures against CSRF. To successfully find and exploit a CSRF vulnerability we need to bypass the defenses employed by the target website and the victim's browser. The most common defenses are:
* CSRF tokens (by the target website): It is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.
* SameSite cookies (by the victim's browser): Security mechanism that determines when website's cookies are included in requests originating from other websites. As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from triggering these actions cross-site. Since 2021, Chrome enforces Lax SameSite restrictions by default.
* Referer-based validation: Use of the HTTP Referer header to attempt to defend against CSRF, normally by verifying that the request originated from the application's own domain. This is generally less effective than CSRF token validation.

# CSRF token

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

A common way to share CSRF tokens with the client is to include them as a hidden parameter in an HTML form:
```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

Some other applications choose to place CSRF tokens in HTTP headers, for example.

## Common flaws in CSRF tokens

### Validation of CSRF token depends on request method

 Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

Switch to the GET method to bypass the validation and deliver a CSRF attack:
```html
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```
Switching the HTTP request method is also known as **HTTP Verb Tampering**.

### Validation of CSRF token depends on token being present

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

Remove the entire parameter containing the token (not just its value) to bypass the validation and deliver a CSRF attack:
```html
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

email=pwned@evil-user.net
```

### CSRF token is not tied to the user session

 Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

Log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

### CSRF token is tied to a non-session cookie

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:
```html
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

Here the **cookie csrfKey** is tied to the **token csrf**. If the attacker injects his own csrfKey cookie (obtained by logging in using his own account) in a victim's browser, he knows the corresponding csrf token to perform the action. Of course the website needs to contain a vulnerability that allows the attacker to set a cookie in  a victim's browser, such as XSS.

The cookie-setting behavior does not even need to exist within the same web application as the CSRF vulnerability. Any other application within the same overall DNS domain can potentially be leveraged to set cookies in the application that is being targeted, if the cookie that is controlled has suitable scope. For example, a cookie-setting function on staging.demo.normal-website.com could be leveraged to place a cookie that is submitted to secure.normal-website.com.

### CSRF token is simply duplicated in a cookie

Some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:
```html
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

The attacker can again perform a CSRF attack if the website contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.
